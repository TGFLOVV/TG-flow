import { db } from "./db";
import {
  users,
  categories,
  channels,
  channelApplications,
  payments,
  ratings,
  channelViews,
  bots,
  groups,
  news,
  notifications,
  withdrawalRequests,
  supportMessages,
  supportFiles,
  type User,
  type InsertUser,
  type Category,
  type InsertCategory,
  type Channel,
  type InsertChannel,
  type ChannelApplication,
  type InsertChannelApplication,
  type Payment,
  type InsertPayment,
  type Rating,
  type InsertRating,
  type ChannelView,
  type InsertChannelView,
  type Bot,
  type InsertBot,
  type Group,
  type InsertGroup,
  type News,
  type InsertNews,
  type Notification,
  type InsertNotification,
  type WithdrawalRequest,
  type InsertWithdrawalRequest,
  type SupportMessage,
  type InsertSupportMessage,
  type SupportFile,
  type InsertSupportFile,
} from "@shared/schema";
import { eq, and } from "drizzle-orm";

export interface IStorage {
  // User operations
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  getAllUsers(): Promise<User[]>;
  updateUserBalance(userId: number, amount: string): Promise<User>;
  updateUserStatus(userId: number, status: string): Promise<User>;
  updateUserSettings(userId: number, settings: { starfieldEnabled?: boolean }): Promise<User>;
  updateUserAvatar(userId: number, profileImageUrl: string): Promise<User>;
  getUserTopupHistory(userId: number): Promise<Payment[]>;

  // Category operations
  getCategories(): Promise<Category[]>;
  createCategory(category: InsertCategory): Promise<Category>;

  // Channel operations
  getChannels(limit?: number, categoryId?: number, type?: string): Promise<(Channel & { category: Category; owner: User })[]>;
  getChannelById(id: number): Promise<(Channel & { category: Category; owner: User }) | undefined>;
  getChannelsByOwner(ownerId: number): Promise<(Channel & { category: Category; owner: User })[]>;
  createChannel(channel: InsertChannel): Promise<Channel>;
  updateChannelStatus(id: number, status: string): Promise<Channel>;
  updateChannel(id: number, updates: Partial<Channel>): Promise<Channel>;
  deleteChannel(id: number): Promise<void>;
  getChannelsByUser(userId: number): Promise<(Channel & { category: Category })[]>;

  // Application operations
  getApplications(status?: string): Promise<(ChannelApplication & { category: Category; applicant: User })[]>;
  createApplication(application: InsertChannelApplication): Promise<ChannelApplication>;
  updateApplicationStatus(id: number, status: string, reviewerId: number, rejectionReason?: string): Promise<ChannelApplication>;

  // Payment operations
  createPayment(payment: InsertPayment): Promise<Payment>;

  // Rating operations
  rateChannel(channelId: number, userId: number, rating: number): Promise<void>;
  getChannelRating(channelId: number): Promise<{ averageRating: number; totalRatings: number }>;

  // View operations
  addChannelView(channelId: number, userId: number): Promise<void>;
  getChannelViews(channelId: number): Promise<number>;

  // Stats operations
  getStats(): Promise<{
    totalChannels: number;
    totalUsers: number;
    pendingApplications: number;
    totalRevenue: string;
  }>;

  getUserByEmail(email: string): Promise<User | undefined>;
  updateUserRole(userId: number, role: string): Promise<User>;

  // Additional methods needed by routes
  promoteChannelToTop(id: number, durationDays: number): Promise<Channel>;
  promoteChannelToUltraTop(id: number, durationDays: number): Promise<Channel>;
  cleanupExpiredPromotions(): Promise<void>;
  getChannelByUsername(username: string): Promise<Channel | null>;
  getChannelsWithBotAdmin(): Promise<Channel[]>;
  updateUserProfile(userId: number, profileData: { firstName?: string, lastName?: string }): Promise<User>;
  updateUserEmail(userId: number, email: string): Promise<User>;
  getUserByGoogleId(googleId: string): Promise<User | undefined>;
  getUserByTelegramId(telegramId: string): Promise<User | undefined>;
  updateUserGoogleId(userId: number, googleId: string): Promise<User>;
  updateUserTelegramData(userId: number, telegramData: any): Promise<User>;
  createUserFromTelegram(telegramData: any): Promise<User>;
  getNotifications(userId: number): Promise<Notification[]>;
  createNotification(notification: InsertNotification): Promise<Notification>;
  markNotificationAsRead(notificationId: number): Promise<void>;
  markAllNotificationsAsRead(userId: number): Promise<void>;
  getUnreadNotificationCount(userId: number): Promise<number>;
  savePasswordResetCode(userId: number, code: string): Promise<boolean>;
  verifyPasswordResetCode(code: string, newPassword: string): Promise<{ success: boolean; error?: string }>;
  getUserStatistics(userId: number): Promise<any>;
  createWithdrawalRequest(request: InsertWithdrawalRequest): Promise<WithdrawalRequest>;
  getWithdrawalRequests(status?: string): Promise<WithdrawalRequest[]>;
  getUserWithdrawalRequests(userId: number): Promise<WithdrawalRequest[]>;
  updateWithdrawalRequestStatus(requestId: number, status: string, processedBy: number, rejectionReason?: string): Promise<WithdrawalRequest>;
  getBroadcastStats(): Promise<any>;
  getUsersForEmailBroadcast(): Promise<User[]>;
  getUsersForTelegramBroadcast(): Promise<User[]>;
  getSupportMessages(userId: number): Promise<any[]>;
  getSupportChats(): Promise<any[]>;
  getSupportChatById(chatId: string): Promise<any | null>;
  getUnreadSupportCount(userId: number): Promise<number>;
  createSupportMessage(data: any): Promise<any>;
  markSupportMessagesAsRead(userId: number, chatId: string): Promise<void>;
  createSupportFile(fileData: InsertSupportFile): Promise<SupportFile>;
  getSupportFile(filename: string): Promise<SupportFile | null>;
  getSupportFileByMessageId(messageId: number): Promise<SupportFile | null>;
  resolveSupportChat(chatId: string): Promise<void>;
  getLandingStats(): Promise<any>;
  getUserTopups(userId: number): Promise<Payment[]>;
  getTopups(status?: string): Promise<Payment[]>;
  getUserApplications(userId: number): Promise<ChannelApplication[]>;
  getUserApplicationsByStatus(userId: number, status: string): Promise<ChannelApplication[]>;
  getUserChannels(userId: number): Promise<any[]>;
  getBots(limit?: number, categoryId?: number): Promise<(Bot & { category: Category; owner: User })[]>;
  getBotById(id: number): Promise<(Bot & { category: Category; owner: User }) | undefined>;
  createBot(bot: InsertBot): Promise<Bot>;
  updateBot(id: number, updates: Partial<Bot>): Promise<Bot>;
  deleteBot(id: number): Promise<void>;
  getGroups(limit?: number, categoryId?: number): Promise<(Group & { category: Category; owner: User })[]>;
  getGroupById(id: number): Promise<(Group & { category: Category; owner: User }) | undefined>;
  createGroup(group: InsertGroup): Promise<Group>;
  updateGroup(id: number, updates: Partial<Group>): Promise<Group>;
  deleteGroup(id: number): Promise<void>;
  getNews(limit?: number): Promise<(News & { author: User })[]>;
  getNewsById(id: number): Promise<(News & { author: User }) | undefined>;
  createNews(news: InsertNews): Promise<News>;
  updateNews(id: number, updates: Partial<News>): Promise<News>;
  deleteNews(id: number): Promise<void>;
  getChannelViews24h(channelId: number): Promise<number>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user;
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    if (!email || !email.trim()) {
      return undefined;
    }
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user;
  }

  async createUser(userData: InsertUser): Promise<User> {
    const [user] = await db.insert(users).values(userData).returning();
    return user;
  }

  async getAllUsers(): Promise<User[]> {
    return await db.select().from(users);
  }

  async updateUserBalance(userId: number, amount: string): Promise<User> {
    const [user] = await db
      .update(users)
      .set({ balance: amount, updatedAt: new Date() })
      .where(eq(users.id, userId))
      .returning();
    return user;
  }

  async updateUserStatus(userId: number, status: string): Promise<User> {
    const [user] = await db
      .update(users)
      .set({ status, updatedAt: new Date() })
      .where(eq(users.id, userId))
      .returning();
    return user;
  }

  async updateUserSettings(userId: number, settings: { starfieldEnabled?: boolean }): Promise<User> {
    const [user] = await db
      .update(users)
      .set({ ...settings, updatedAt: new Date() })
      .where(eq(users.id, userId))
      .returning();
    return user;
  }

  async updateUserAvatar(userId: number, profileImageUrl: string): Promise<User> {
    const [user] = await db
      .update(users)
      .set({ profileImageUrl, updatedAt: new Date() })
      .where(eq(users.id, userId))
      .returning();
    return user;
  }

  async updateUserRole(userId: number, role: string): Promise<User> {
    const [user] = await db
      .update(users)
      .set({ role, updatedAt: new Date() })
      .where(eq(users.id, userId))
      .returning();
    return user;
  }

  async getUserTopupHistory(userId: number): Promise<Payment[]> {
    return await db.select().from(payments).where(eq(payments.userId, userId));
  }

  async getCategories(): Promise<Category[]> {
    return await db.select().from(categories);
  }

  async createCategory(category: InsertCategory): Promise<Category> {
    const [newCategory] = await db.insert(categories).values(category).returning();
    return newCategory;
  }

  async getChannels(limit = 50, categoryId?: number, type?: string): Promise<(Channel & { category: Category; owner: User })[]> {
    // Simplified implementation - return basic channels with joined data
    const result = await db
      .select()
      .from(channels)
      .innerJoin(categories, eq(channels.categoryId, categories.id))
      .innerJoin(users, eq(channels.ownerId, users.id))
      .limit(limit);
    
    return result.map(row => ({
      ...row.channels,
      category: row.categories,
      owner: row.users
    }));
  }

  async getChannelById(id: number): Promise<(Channel & { category: Category; owner: User }) | undefined> {
    const [result] = await db
      .select()
      .from(channels)
      .innerJoin(categories, eq(channels.categoryId, categories.id))
      .innerJoin(users, eq(channels.ownerId, users.id))
      .where(eq(channels.id, id));
    
    if (!result) return undefined;
    
    return {
      ...result.channels,
      category: result.categories,
      owner: result.users
    };
  }

  async getChannelsByOwner(ownerId: number): Promise<(Channel & { category: Category; owner: User })[]> {
    const result = await db
      .select()
      .from(channels)
      .innerJoin(categories, eq(channels.categoryId, categories.id))
      .innerJoin(users, eq(channels.ownerId, users.id))
      .where(eq(channels.ownerId, ownerId));
    
    return result.map(row => ({
      ...row.channels,
      category: row.categories,
      owner: row.users
    }));
  }

  async createChannel(channel: InsertChannel): Promise<Channel> {
    const [newChannel] = await db.insert(channels).values(channel).returning();
    return newChannel;
  }

  async updateChannelStatus(id: number, status: string): Promise<Channel> {
    const [channel] = await db
      .update(channels)
      .set({ status, updatedAt: new Date() })
      .where(eq(channels.id, id))
      .returning();
    return channel;
  }

  async updateChannel(id: number, updates: Partial<Channel>): Promise<Channel> {
    const [channel] = await db
      .update(channels)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(channels.id, id))
      .returning();
    return channel;
  }

  async deleteChannel(id: number): Promise<void> {
    // Delete related data first
    await db.delete(ratings).where(eq(ratings.channelId, id));
    await db.delete(channelViews).where(eq(channelViews.channelId, id));
    // Delete the channel
    await db.delete(channels).where(eq(channels.id, id));
  }

  async getChannelsByUser(userId: number): Promise<(Channel & { category: Category })[]> {
    const result = await db
      .select()
      .from(channels)
      .innerJoin(categories, eq(channels.categoryId, categories.id))
      .where(eq(channels.ownerId, userId));
    
    return result.map(row => ({
      ...row.channels,
      category: row.categories
    }));
  }

  async getApplications(status?: string): Promise<(ChannelApplication & { category: Category; applicant: User })[]> {
    let query = db
      .select()
      .from(channelApplications)
      .innerJoin(categories, eq(channelApplications.categoryId, categories.id))
      .innerJoin(users, eq(channelApplications.applicantId, users.id));
    
    if (status) {
      query = query.where(eq(channelApplications.status, status));
    }
    
    const result = await query;
    return result.map(row => ({
      ...row.channel_applications,
      category: row.categories,
      applicant: row.users
    }));
  }

  async createApplication(application: InsertChannelApplication): Promise<ChannelApplication> {
    const [newApplication] = await db.insert(channelApplications).values(application).returning();
    return newApplication;
  }

  async updateApplicationStatus(id: number, status: string, reviewerId: number, rejectionReason?: string): Promise<ChannelApplication> {
    const [application] = await db
      .update(channelApplications)
      .set({
        status,
        reviewerId,
        rejectionReason,
        updatedAt: new Date()
      })
      .where(eq(channelApplications.id, id))
      .returning();
    return application;
  }

  async createPayment(payment: InsertPayment): Promise<Payment> {
    const [newPayment] = await db.insert(payments).values(payment).returning();
    return newPayment;
  }

  async rateChannel(channelId: number, userId: number, rating: number): Promise<void> {
    await db
      .insert(ratings)
      .values({ channelId, userId, rating })
      .onConflictDoUpdate({
        target: [ratings.channelId, ratings.userId],
        set: { rating }
      });
  }

  async getChannelRating(channelId: number): Promise<{ averageRating: number; totalRatings: number }> {
    const result = await db
      .select()
      .from(ratings)
      .where(eq(ratings.channelId, channelId));
    
    if (result.length === 0) {
      return { averageRating: 0, totalRatings: 0 };
    }
    
    const totalRatings = result.length;
    const averageRating = result.reduce((sum, r) => sum + r.rating, 0) / totalRatings;
    
    return { averageRating: Math.round(averageRating * 100) / 100, totalRatings };
  }

  async addChannelView(channelId: number, userId: number): Promise<void> {
    await db.insert(channelViews).values({ channelId, userId });
  }

  async getChannelViews(channelId: number): Promise<number> {
    const result = await db.select().from(channelViews).where(eq(channelViews.channelId, channelId));
    return result.length;
  }

  async getStats(): Promise<{
    totalChannels: number;
    totalUsers: number;
    pendingApplications: number;
    totalRevenue: string;
  }> {
    const [channelsCount] = await db.select().from(channels);
    const [usersCount] = await db.select().from(users);
    const [applicationsCount] = await db.select().from(channelApplications).where(eq(channelApplications.status, 'pending'));
    const paymentsResult = await db.select().from(payments);
    
    const totalRevenue = paymentsResult.reduce((sum, p) => sum + parseFloat(p.amount), 0).toString();
    
    return {
      totalChannels: channelsCount ? 1 : 0,
      totalUsers: usersCount ? 1 : 0,
      pendingApplications: applicationsCount ? 1 : 0,
      totalRevenue
    };
  }

  // Additional method implementations
  async promoteChannelToTop(id: number, durationDays: number): Promise<Channel> {
    const expiry = new Date();
    expiry.setDate(expiry.getDate() + durationDays);
    
    const [channel] = await db
      .update(channels)
      .set({ 
        isTopPromoted: true, 
        topPromotionExpiry: expiry,
        updatedAt: new Date()
      })
      .where(eq(channels.id, id))
      .returning();
    return channel;
  }

  async promoteChannelToUltraTop(id: number, durationDays: number): Promise<Channel> {
    const expiry = new Date();
    expiry.setDate(expiry.getDate() + durationDays);
    
    const [channel] = await db
      .update(channels)
      .set({ 
        isUltraTopPromoted: true, 
        ultraTopPromotionExpiry: expiry,
        updatedAt: new Date()
      })
      .where(eq(channels.id, id))
      .returning();
    return channel;
  }

  async cleanupExpiredPromotions(): Promise<void> {
    const now = new Date();
    await db
      .update(channels)
      .set({ isTopPromoted: false })
      .where(and(
        eq(channels.isTopPromoted, true),
        // topPromotionExpiry < now
      ));
    
    await db
      .update(channels)
      .set({ isUltraTopPromoted: false })
      .where(and(
        eq(channels.isUltraTopPromoted, true),
        // ultraTopPromotionExpiry < now
      ));
  }

  async getChannelByUsername(username: string): Promise<Channel | null> {
    const [channel] = await db.select().from(channels).where(eq(channels.channelUrl, username));
    return channel || null;
  }

  async getChannelsWithBotAdmin(): Promise<Channel[]> {
    return await db.select().from(channels);
  }

  async updateUserProfile(userId: number, profileData: { firstName?: string, lastName?: string }): Promise<User> {
    const [user] = await db
      .update(users)
      .set({ ...profileData, updatedAt: new Date() })
      .where(eq(users.id, userId))
      .returning();
    return user;
  }

  async updateUserEmail(userId: number, email: string): Promise<User> {
    const [user] = await db
      .update(users)
      .set({ email, updatedAt: new Date() })
      .where(eq(users.id, userId))
      .returning();
    return user;
  }

  async getUserByGoogleId(googleId: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.googleId, googleId));
    return user;
  }

  async getUserByTelegramId(telegramId: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.telegramId, telegramId));
    return user;
  }

  async updateUserGoogleId(userId: number, googleId: string): Promise<User> {
    const [user] = await db
      .update(users)
      .set({ googleId, updatedAt: new Date() })
      .where(eq(users.id, userId))
      .returning();
    return user;
  }

  async updateUserTelegramData(userId: number, telegramData: any): Promise<User> {
    const [user] = await db
      .update(users)
      .set({ 
        telegramId: telegramData.telegramId,
        telegramUsername: telegramData.telegramUsername,
        telegramFirstName: telegramData.telegramFirstName,
        telegramLastName: telegramData.telegramLastName,
        telegramPhotoUrl: telegramData.telegramPhotoUrl,
        updatedAt: new Date()
      })
      .where(eq(users.id, userId))
      .returning();
    return user;
  }

  async createUserFromTelegram(telegramData: any): Promise<User> {
    const userData: InsertUser = {
      username: telegramData.telegramUsername || `user_${telegramData.telegramId}`,
      telegramId: telegramData.telegramId,
      telegramUsername: telegramData.telegramUsername,
      telegramFirstName: telegramData.telegramFirstName,
      telegramLastName: telegramData.telegramLastName,
      telegramPhotoUrl: telegramData.telegramPhotoUrl,
      role: 'user',
      status: 'active'
    };
    return await this.createUser(userData);
  }

  async getNotifications(userId: number): Promise<Notification[]> {
    return await db.select().from(notifications).where(eq(notifications.userId, userId));
  }

  async createNotification(notification: InsertNotification): Promise<Notification> {
    const [newNotification] = await db.insert(notifications).values(notification).returning();
    return newNotification;
  }

  async markNotificationAsRead(notificationId: number): Promise<void> {
    await db
      .update(notifications)
      .set({ isRead: true })
      .where(eq(notifications.id, notificationId));
  }

  async markAllNotificationsAsRead(userId: number): Promise<void> {
    await db
      .update(notifications)
      .set({ isRead: true })
      .where(eq(notifications.userId, userId));
  }

  async getUnreadNotificationCount(userId: number): Promise<number> {
    const result = await db
      .select()
      .from(notifications)
      .where(and(
        eq(notifications.userId, userId),
        eq(notifications.isRead, false)
      ));
    return result.length;
  }

  async savePasswordResetCode(userId: number, code: string): Promise<boolean> {
    try {
      await db
        .update(users)
        .set({ 
          emailVerificationCode: code,
          emailVerificationExpires: new Date(Date.now() + 15 * 60 * 1000), // 15 minutes
          updatedAt: new Date()
        })
        .where(eq(users.id, userId));
      return true;
    } catch {
      return false;
    }
  }

  async verifyPasswordResetCode(code: string, newPassword: string): Promise<{ success: boolean; error?: string }> {
    try {
      const [user] = await db
        .select()
        .from(users)
        .where(eq(users.emailVerificationCode, code));
      
      if (!user) {
        return { success: false, error: 'Invalid code' };
      }

      if (user.emailVerificationExpires && user.emailVerificationExpires < new Date()) {
        return { success: false, error: 'Code expired' };
      }

      await db
        .update(users)
        .set({
          password: newPassword,
          emailVerificationCode: null,
          emailVerificationExpires: null,
          updatedAt: new Date()
        })
        .where(eq(users.id, user.id));

      return { success: true };
    } catch {
      return { success: false, error: 'Server error' };
    }
  }

  async getUserStatistics(userId: number): Promise<any> {
    const userChannels = await db.select().from(channels).where(eq(channels.ownerId, userId));
    const userApplications = await db.select().from(channelApplications).where(eq(channelApplications.applicantId, userId));
    
    return {
      totalChannels: userChannels.length,
      totalBots: 0,
      totalGroups: 0,
      totalPublications: userChannels.length,
      totalViews: 0,
      viewsThisMonth: 0,
      totalSubscribers: 0,
      totalEarnings: "0.00",
      approvedApplications: userApplications.filter(app => app.status === 'approved').length,
      pendingApplications: userApplications.filter(app => app.status === 'pending').length,
      rejectedApplications: userApplications.filter(app => app.status === 'rejected').length,
      avgRating: 0,
      joinedDate: new Date().toISOString()
    };
  }

  async createWithdrawalRequest(request: InsertWithdrawalRequest): Promise<WithdrawalRequest> {
    const [newRequest] = await db.insert(withdrawalRequests).values(request).returning();
    return newRequest;
  }

  async getWithdrawalRequests(status?: string): Promise<WithdrawalRequest[]> {
    if (status) {
      return await db.select().from(withdrawalRequests).where(eq(withdrawalRequests.status, status));
    }
    return await db.select().from(withdrawalRequests);
  }

  async getUserWithdrawalRequests(userId: number): Promise<WithdrawalRequest[]> {
    return await db.select().from(withdrawalRequests).where(eq(withdrawalRequests.userId, userId));
  }

  async updateWithdrawalRequestStatus(
    requestId: number, 
    status: string, 
    processedBy: number, 
    rejectionReason?: string
  ): Promise<WithdrawalRequest> {
    const [request] = await db
      .update(withdrawalRequests)
      .set({
        status,
        processedBy,
        rejectionReason,
        updatedAt: new Date()
      })
      .where(eq(withdrawalRequests.id, requestId))
      .returning();
    return request;
  }

  async getBroadcastStats(): Promise<any> {
    const users = await db.select().from(users);
    return {
      totalUsers: users.length,
      emailUsers: users.filter(u => u.email).length,
      telegramUsers: users.filter(u => u.telegramId).length
    };
  }

  async getUsersForEmailBroadcast(): Promise<User[]> {
    return await db.select().from(users).where(eq(users.email, users.email)); // Simple check for non-null email
  }

  async getUsersForTelegramBroadcast(): Promise<User[]> {
    return await db.select().from(users).where(eq(users.telegramId, users.telegramId)); // Simple check for non-null telegram
  }

  async getSupportMessages(userId: number): Promise<any[]> {
    return await db.select().from(supportMessages).where(eq(supportMessages.userId, userId));
  }

  async getSupportChats(): Promise<any[]> {
    return await db.select().from(supportMessages);
  }

  async getSupportChatById(chatId: string): Promise<any | null> {
    const [chat] = await db.select().from(supportMessages).where(eq(supportMessages.chatId, chatId));
    return chat || null;
  }

  async getUnreadSupportCount(userId: number): Promise<number> {
    const result = await db
      .select()
      .from(supportMessages)
      .where(and(
        eq(supportMessages.userId, userId),
        eq(supportMessages.isRead, false)
      ));
    return result.length;
  }

  async createSupportMessage(data: any): Promise<any> {
    const [message] = await db.insert(supportMessages).values(data).returning();
    return message;
  }

  async markSupportMessagesAsRead(userId: number, chatId: string): Promise<void> {
    await db
      .update(supportMessages)
      .set({ isRead: true })
      .where(and(
        eq(supportMessages.userId, userId),
        eq(supportMessages.chatId, chatId)
      ));
  }

  async createSupportFile(fileData: InsertSupportFile): Promise<SupportFile> {
    const [file] = await db.insert(supportFiles).values(fileData).returning();
    return file;
  }

  async getSupportFile(filename: string): Promise<SupportFile | null> {
    const [file] = await db.select().from(supportFiles).where(eq(supportFiles.filename, filename));
    return file || null;
  }

  async getSupportFileByMessageId(messageId: number): Promise<SupportFile | null> {
    const [file] = await db.select().from(supportFiles).where(eq(supportFiles.messageId, messageId));
    return file || null;
  }

  async resolveSupportChat(chatId: string): Promise<void> {
    // Mark all messages in chat as resolved (implementation depends on requirements)
    await db
      .update(supportMessages)
      .set({ isRead: true })
      .where(eq(supportMessages.chatId, chatId));
  }

  async getLandingStats(): Promise<any> {
    const channelsResult = await db.select().from(channels);
    const usersResult = await db.select().from(users);
    const categoriesResult = await db.select().from(categories);
    
    return {
      totalChannels: channelsResult.length,
      totalUsers: usersResult.length,
      totalCategories: categoriesResult.length
    };
  }

  async getUserTopups(userId: number): Promise<Payment[]> {
    return await db.select().from(payments).where(eq(payments.userId, userId));
  }

  async getTopups(status?: string): Promise<Payment[]> {
    if (status) {
      return await db.select().from(payments).where(eq(payments.status, status));
    }
    return await db.select().from(payments);
  }

  async getUserApplications(userId: number): Promise<ChannelApplication[]> {
    return await db.select().from(channelApplications).where(eq(channelApplications.applicantId, userId));
  }

  async getUserApplicationsByStatus(userId: number, status: string): Promise<ChannelApplication[]> {
    return await db
      .select()
      .from(channelApplications)
      .where(and(
        eq(channelApplications.applicantId, userId),
        eq(channelApplications.status, status)
      ));
  }

  async getUserChannels(userId: number): Promise<any[]> {
    return await this.getChannelsByUser(userId);
  }

  async getBots(limit = 50, categoryId?: number): Promise<(Bot & { category: Category; owner: User })[]> {
    let query = db
      .select()
      .from(bots)
      .innerJoin(categories, eq(bots.categoryId, categories.id))
      .innerJoin(users, eq(bots.ownerId, users.id))
      .limit(limit);
    
    if (categoryId) {
      query = query.where(eq(bots.categoryId, categoryId));
    }
    
    const result = await query;
    return result.map(row => ({
      ...row.bots,
      category: row.categories,
      owner: row.users
    }));
  }

  async getBotById(id: number): Promise<(Bot & { category: Category; owner: User }) | undefined> {
    const [result] = await db
      .select()
      .from(bots)
      .innerJoin(categories, eq(bots.categoryId, categories.id))
      .innerJoin(users, eq(bots.ownerId, users.id))
      .where(eq(bots.id, id));
    
    if (!result) return undefined;
    
    return {
      ...result.bots,
      category: result.categories,
      owner: result.users
    };
  }

  async createBot(bot: InsertBot): Promise<Bot> {
    const [newBot] = await db.insert(bots).values(bot).returning();
    return newBot;
  }

  async updateBot(id: number, updates: Partial<Bot>): Promise<Bot> {
    const [bot] = await db
      .update(bots)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(bots.id, id))
      .returning();
    return bot;
  }

  async deleteBot(id: number): Promise<void> {
    await db.delete(bots).where(eq(bots.id, id));
  }

  async getGroups(limit = 50, categoryId?: number): Promise<(Group & { category: Category; owner: User })[]> {
    let query = db
      .select()
      .from(groups)
      .innerJoin(categories, eq(groups.categoryId, categories.id))
      .innerJoin(users, eq(groups.ownerId, users.id))
      .limit(limit);
    
    if (categoryId) {
      query = query.where(eq(groups.categoryId, categoryId));
    }
    
    const result = await query;
    return result.map(row => ({
      ...row.groups,
      category: row.categories,
      owner: row.users
    }));
  }

  async getGroupById(id: number): Promise<(Group & { category: Category; owner: User }) | undefined> {
    const [result] = await db
      .select()
      .from(groups)
      .innerJoin(categories, eq(groups.categoryId, categories.id))
      .innerJoin(users, eq(groups.ownerId, users.id))
      .where(eq(groups.id, id));
    
    if (!result) return undefined;
    
    return {
      ...result.groups,
      category: result.categories,
      owner: result.users
    };
  }

  async createGroup(group: InsertGroup): Promise<Group> {
    const [newGroup] = await db.insert(groups).values(group).returning();
    return newGroup;
  }

  async updateGroup(id: number, updates: Partial<Group>): Promise<Group> {
    const [group] = await db
      .update(groups)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(groups.id, id))
      .returning();
    return group;
  }

  async deleteGroup(id: number): Promise<void> {
    await db.delete(groups).where(eq(groups.id, id));
  }

  async getNews(limit = 50): Promise<(News & { author: User })[]> {
    const result = await db
      .select()
      .from(news)
      .innerJoin(users, eq(news.authorId, users.id))
      .limit(limit);
    
    return result.map(row => ({
      ...row.news,
      author: row.users
    }));
  }

  async getNewsById(id: number): Promise<(News & { author: User }) | undefined> {
    const [result] = await db
      .select()
      .from(news)
      .innerJoin(users, eq(news.authorId, users.id))
      .where(eq(news.id, id));
    
    if (!result) return undefined;
    
    return {
      ...result.news,
      author: result.users
    };
  }

  async createNews(newsData: InsertNews): Promise<News> {
    const [newNews] = await db.insert(news).values(newsData).returning();
    return newNews;
  }

  async updateNews(id: number, updates: Partial<News>): Promise<News> {
    const [newsItem] = await db
      .update(news)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(news.id, id))
      .returning();
    return newsItem;
  }

  async deleteNews(id: number): Promise<void> {
    await db.delete(news).where(eq(news.id, id));
  }

  async getChannelViews24h(channelId: number): Promise<number> {
    const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
    const result = await db
      .select()
      .from(channelViews)
      .where(and(
        eq(channelViews.channelId, channelId),
        // createdAt > twentyFourHoursAgo (would need proper date comparison)
      ));
    return result.length;
  }
}

export const storage = new DatabaseStorage();